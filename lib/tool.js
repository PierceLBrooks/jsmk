/* global jsmk */
var path = require("path");
var SettingsContainer = require("./settingscontainer.js").SettingsContainer;

var Semantics =
{
    OneToNone: "OneToNone",
    OneToOne: "OneToOne",
    ManyToOne: "ManyToOne",
    ManyToMany: "ManyToMany"
};

var Role = // NB: stage and role, often correlated, are orthogonal
{
    Archive:    "Archive", // incl ar, tar, zip
    Extract:    "Extract", // objcopy, un-archive
    Strip:      "Strip",   // symbol-strip, etc.
    Compile:    "Compile", // c, rsl, uglify
    Link:       "Link",
    Clean:      "Clean",
    Copy:       "Copy",
    Test:       "Test",
    Benchmark:  "Benchmark",
    Sync:       "Sync",    // git, perforce
    Reposit:    "Reposit", // ftp, scp, rsync
    Deploy:     "Deploy", // download to arduino, etc
};

// A Tool is a SettingsContainer that embodies all the Settings
// associated with and individual tool.   Tool settings can be
// composed via inheritance or by explicitly combining with other
// SettingsContainers.
//
// Work is generated by composing the Tool settings with the Task settings.
//
class Tool extends SettingsContainer
{
    constructor(toolset, name, config)
    {
        super();
        this.m_toolset = toolset;
        this.m_name = name;
        this.m_role = config.Role;
        this.m_semantics = config.Semantics;
        this.m_dstExt = config.DstExt;
        this.m_actionStage = config.ActionStage ? config.ActionStage : "build";
        this.m_syntax = config.Syntax;
        this.MergeSettings(toolset);
    }

    GetToolset()
    {
        return this.m_toolset;
    }

    GetRole()
    {
        return this.m_role;
    }

    ConfigureTaskSettings(task)
    {
        // for just-in-time configuration
    }

    // DstFilesFromSrc:
    //  given a list of fully-qualified src files, return a list
    //  of one or more dst file pathnames. Tools currently must follow
    //  many-to-many (eg compilation) and many-to-one pattern (eg link).
    DstFilesFromSrc(taskname, srcfiles, dstDir)
    {
        var dstfiles = [];
        switch(this.m_semantics)
        {
        case Semantics.ManyToOne:
            var dstfile = this.buildDstFileName(taskname, dstDir);
            dstfiles.push(dstfile);
            break;
        case Semantics.OneToOne:
        case Semantics.ManyToMany:
            let self = this;
            dstfiles = srcfiles ? srcfiles.map( function(srcfile)
                    {
                        return self.buildDstFileName(srcfile, dstDir);
                    }) : [];
            // console.log("task outputs", dstfiles);
            break;
        case Semantics.OneToNone:
            break;
        default:
            throw new Error(this.m_name + ": Unknown tool semantics: " + this.m_semantics);
        }
        return dstfiles;
    }

    BeginStage(stage, task)
    {
        /* not all tools need implement BeginStage */
    }

    // GenerateWork is a generator (ie: issues yield) of Promises
    *GenerateWork(stage, task, inputs, outputs)
    {
        throw new Error("tools must implement GenerateWork method");
    }

    EndStage(stage, task)
    {
        /* not all tools need implement EndStage */
    }

    // protected ---------------------------------------------
    outputIsDirty(output, inputs, cwd)
    {
        if(typeof inputs === "string")
            inputs = [inputs];
        for(let input of inputs)
        {
            let ifile = jsmk.path.isAbsolute(input) ? input :
                                    jsmk.path.join(cwd, input);
            if(jsmk.file.newer(ifile, output))
                return true;
        }
        return false;
    }

    // private -----------------------------------------------------------
    buildDstFileName(srcfile, dstDir)
    {
        var srcp = path.parse(srcfile);
        srcp.dir = dstDir;
        // NB: esp8266's ld scripts assume that files are named like:
        //  foo.cpp.o, not foo.o... We can live with this right?
        srcp.base = srcp.base + "." + this.m_dstExt; // nb base is used by format...
        srcp.ext = "." + this.m_dstExt;
        let result = jsmk.path.normalize(path.format(srcp));
        // jsmk.NOTICE(`${srcfile} -> ${result}`);
        return result;
    }
}

// class variables, enums, etc
Tool.Semantics = Semantics;
Tool.Role = Role;
exports.Tool = Tool;
